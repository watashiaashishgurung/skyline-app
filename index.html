<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skyline ‚Äì Offline Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    /* Autumn theme palette */
    :root { --bg:#2a1a12; --card:#3b2417; --ink:#ffeedd; --muted:#d8b8a0; --accent:#ff8c42; --grid:#5a3a28; }
    *{box-sizing:border-box}
  body{margin:0;padding:24px;color:var(--ink);background:linear-gradient(180deg,#2a1a12,#3b2417 45%,#2a1a12);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,"Noto Sans",Arial,sans-serif;overflow-x:hidden}
  h1{font-family:"Press Start 2P",monospace;font-size:20px;text-align:center;margin:0 0 16px;color:var(--accent)}
    .flex-header{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-bottom:12px}
    button{background:var(--card);border:1px solid #2a2f4b;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
    button:hover{border-color:var(--accent)}
  .card{max-width:980px;margin:12px auto;background:linear-gradient(160deg,#3b2417,#2a1a12 85%);border:1px solid #5a3a28;border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.4)}
    .button-container{margin-top:10px}
    label{display:block;margin:10px 0 6px;color:var(--muted)}
  input[type="number"],input[type="text"]{width:100%;background:#2d1c13;color:var(--ink);border:1px solid #5a3a28;border-radius:10px;padding:10px}
    #instructions ul{margin:8px 0 0 18px}
    #round-info{font-weight:700;margin-bottom:4px}
    #round-note{color:var(--muted);margin-bottom:8px}
    #guesses .row{display:grid;grid-template-columns:1fr 200px;gap:10px;align-items:center;margin:8px 0}
  .hint{font-size:12px;color:#ffb347}
    #output{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;color:#cfe3ff;margin-top:10px}
    .scoreboard table{width:100%;border-collapse:collapse;margin-top:8px}
      .scoreboard th,.scoreboard td{padding:8px;border-bottom:1px solid #273057;text-align:left;font-size:14px}
      .scoreboard + .scoreboard{margin-top:12px}
  .ok{color:#7ddc82}.warn{color:#ffb347}.err{color:#ff9aa2}
    .hidden{display:none !important}
    .flag{font-size:20px}
  canvas{background:#2d1c13;border:1px solid var(--grid);border-radius:12px}

    /* Smooth show/hide for cards */
    .card {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.4s ease;
    }
    .card:not(.hidden) {
      opacity: 1;
      transform: translateY(0);
    }

    /* Button hover pulse */
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 12px var(--accent);
      transition: all 0.2s ease;
    }

    /* Round info flip */
    #round-info {
      display: inline-block;
      animation: roundFlip 0.6s ease;
    }
    @keyframes roundFlip {
      from { transform: rotateX(90deg); opacity: 0; }
      to { transform: rotateX(0deg); opacity: 1; }
    }

    /* Log fade-in */
    #output {
      transition: all 0.3s ease;
    }
    #output span.new {
      animation: fadePop 0.5s ease;
    }
    @keyframes fadePop {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }

    /* Bubble Score Counter */
    #bubble-score {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--card);
      border: 1px solid #2a2f4b;
      border-radius: 12px;
      padding: 12px;
      z-index: 1000;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,.4);
    }
    
    #bubble-score .score-title {
      color: var(--accent);
      margin-bottom: 5px;
    }
    
    #bubble-score .score-line {
      color: var(--ink);
      margin: 3px 0;
    }
    
    #bubble-score .bubbles-left {
      color: var(--muted);
      font-size: 10px;
    }

    /* Leaf Counter HUD */
    #leaf-counter {
      position: fixed;
      top: 20px;
      left: 20px;
      background: var(--card);
      border: 1px solid #ff8c42;
      border-radius: 12px;
      padding: 12px 16px;
      z-index: 1000;
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,.4);
      color: var(--accent);
    }

  /* Leaf physics (JS-driven) */
  .leaves{position:fixed;top:0;left:0;width:100%;height:100%;z-index:999;overflow:hidden;pointer-events:none}
  .leaf{position:fixed;font-size:clamp(18px,3vw,46px);opacity:.95;filter:drop-shadow(0 4px 6px rgba(0,0,0,.4));will-change:transform;transition:filter .3s ease;cursor:pointer;pointer-events:auto}
  .leaf.resting{opacity:.85}
  .leaf.captured{opacity:.55;filter:drop-shadow(0 0 8px rgba(255,140,66,.7))}
  body:before{content:"";position:fixed;inset:0;pointer-events:none;background:radial-gradient(circle at 30% 20%,rgba(255,140,66,.12),transparent 60%),radial-gradient(circle at 70% 40%,rgba(255,179,71,.1),transparent 65%);z-index:0}
  .leaf-hud{position:fixed;top:16px;left:16px;z-index:5;background:rgba(58,36,23,.6);padding:10px 14px;border:1px solid #ff8c42;border-radius:12px;font-family:"Press Start 2P",monospace;font-size:11px;color:var(--ink);-webkit-backdrop-filter:blur(3px);backdrop-filter:blur(3px)}
  .net{position:fixed;bottom:140px;left:50%;transform:translateX(-50%);width:140px;height:80px;border:3px solid #ff8c42;border-radius:18px;background:rgba(255,140,66,.15);z-index:4;-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px);display:flex;align-items:center;justify-content:center;font-size:32px}
  .ground{position:fixed;bottom:0;left:0;width:100%;height:140px;background:linear-gradient(to top,rgba(91,58,40,.55),rgba(91,58,40,.25),transparent 90%);z-index:2;pointer-events:none}
  
  /* Leaf physics animations */
  .leaf {
    animation: leafFall var(--fallDur, 20s) linear infinite;
  }
  .leaf .drift {
    animation: leafDrift var(--driftDur, 6s) ease-in-out infinite alternate;
  }
  .leaf .spin {
    animation: leafSpin var(--spinDur, 4s) linear infinite;
  }
  
  @keyframes leafFall {
    from { transform: translateY(-10vh); }
    to { transform: translateY(calc(100vh + 140px)); }
  }
  
  @keyframes leafDrift {
    from { transform: translateX(-20px); }
    to { transform: translateX(20px); }
  }
  
  @keyframes leafSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
  .victory{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;background:rgba(0,0,0,.55);font-family:"Press Start 2P",monospace;color:var(--accent);text-align:center}
  
  /* Leaf catch notification */
  .time-bonus {
    position: fixed;
    font-family: "Press Start 2P", monospace;
    font-size: 18px;
    color: #ff8c42;
    font-weight: bold;
    pointer-events: none;
    z-index: 1001;
    animation: bonusFloat 1s ease-out forwards;
    text-shadow: 0 0 8px rgba(255,140,66,0.8), 0 2px 4px rgba(0,0,0,0.6);
  }
  
  @keyframes bonusFloat {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    50% { opacity: 1; transform: translateY(-30px) scale(1.2); }
    100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
  }

  /* Game Over / Victory Overlay */
  .game-message-overlay {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    background: rgba(0, 0, 0, 0.85);
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
    animation: fadeIn 0.3s ease;
  }

  .game-message-box {
    background: linear-gradient(160deg, #3b2417, #2a1a12 85%);
    border: 3px solid #ff8c42;
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    font-family: "Press Start 2P", monospace;
    color: var(--ink);
    box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    animation: popIn 0.5s ease;
    max-width: 500px;
  }

  .game-message-title {
    font-size: 32px;
    margin-bottom: 20px;
    color: #ff8c42;
  }

  .game-message-subtitle {
    font-size: 14px;
    margin-bottom: 10px;
    color: #d8b8a0;
  }

  .game-message-button {
    margin-top: 20px;
    padding: 12px 24px;
    background: #ff8c42;
    border: none;
    border-radius: 10px;
    font-family: "Press Start 2P", monospace;
    font-size: 12px;
    color: #2a1a12;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .game-message-button:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255,140,66,0.8);
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  @keyframes popIn {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
  }

  /* Celebration confetti */
  .confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    pointer-events: none;
    z-index: 1999;
    animation: confettiFall 3s linear forwards;
  }

  @keyframes confettiFall {
    0% { transform: translateY(0) rotate(0deg); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
  }
  </style>
</head>
<body>
  <!-- Falling Autumn Leaves Layer -->
  <div class="leaves" id="leaves"></div>

  <!-- Leaf Counter -->
  <div id="leaf-counter">üçÅ Leaves: <span id="leaf-count">0</span></div>

  <h1>üçÇ Skyline: Autumn Edition üçÅ</h1>

  <div class="flex-header">
    <button id="btnInstructions">Show Instructions</button>
    <button id="btnRestartTop">Restart Game</button>
  </div>

  <div id="instructions" class="card hidden">
    <p>üéØ <b>Rules</b></p>
    <ul>
      <li>Only players who haven‚Äôt won yet make a guess each round.</li>
      <li>The <b>lowest unique</b> guess among eligible players wins the round.</li>
      <li>Each player can win only once.</li>
      <li><b>Payments each round:</b> everyone (including the winner) pays the winning guess; the winner receives the total pot.</li>
      <li>When only one player hasn‚Äôt won, an <b>extra final round</b> runs where that last player chooses a bet; then the game <b>finishes</b> üèÅ.</li>
  <li>If two or more players tie for the <b>lowest guess</b>, only those tied players must re-enter with a bet <b>lower than their previous bet</b>. This repeats until a single lowest guess remains (the winner).</li>
    </ul>
  </div>
  <div id="player-setup" class="card">
    <label for="numPlayers">Enter Number of Players (2‚Äì100)</label>
    <input type="number" id="numPlayers" min="2" max="100" />
    <div class="button-container"><button id="btnSetupPlayers">Next</button></div>
  </div>
  </div>
  <div id="player-names" class="card hidden">
    <form id="playerForm"></form>
    <div class="button-container"><button id="btnStart">Start Game</button></div>
  </div>
  </div>

    <div id="round-info"></div>
    <div id="round-note"></div>
    <div id="guesses"></div>
    <div class="button-container flex-buttons hidden" id="round-buttons">
      <button id="btnPlay">Play Round</button>
      <button id="btnReenter">Re-enter Guesses</button>
    </div>
    <div class="scoreboard" id="scoreboard"></div>
  </div>
  </div>
  <!-- Graph + Game Log together -->
  <div id="logwrap" class="card hidden">
    <canvas id="guessChart" height="220"></canvas>
    <div class="log-title">Game Log</div>
    <pre id="output"></pre>
  </div>
  </div>

  <div id="game-finished" class="card hidden">
    <div class="ok"><span class="flag">üèÅ</span> <b>Game Finished</b></div>
    <div class="warn">Use "Restart Game" above to play again.</div>
  </div>

  <!-- Colorful Memory Match Game Section -->
  <style>
    /* Scoped styles to avoid clashing with Skyline app */
    #memory-mini * { box-sizing: border-box; }
    #memory-mini {
      --bg: #2a1a12;
      --card: #3b2417;
      --panel: #2d1c13;
      --accent: #ff8c42;
      --ink: #ffeedd;
      --muted: #d8b8a0;
      --grid: #5a3a28;
      --ok: #ff8c42;
      font-family: Arial, sans-serif;
      width: 100%;
      display: grid;
      place-items: center;
      padding: 1rem;
    }
    #memory-mini .wrap {
      background: linear-gradient(160deg, #3b2417, #2a1a12 85%);
      border: 1px solid #5a3a28;
      border-radius: 16px;
      padding: 16px;
      width: min(880px, 96vw);
      color: var(--ink);
      box-shadow: 0 6px 24px rgba(0,0,0,.4);
    }
    #memory-mini h2 {
      margin: 0 0 8px 0;
      text-align: center;
      font-size: 1.6rem;
      line-height: 1.2;
      color: var(--accent);
      font-family: "Press Start 2P", monospace;
    }
    #memory-mini .box {
      background: transparent;
      border-radius: 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 16px;
      align-items: start;
    }
    #memory-mini #game-container {
      display: grid;
      grid-template-columns: repeat(4, 100px);
      gap: 10px;
      background: var(--panel);
      border: 1px solid var(--grid);
      padding: 10px;
      border-radius: 10px;
      justify-content: center;
    }
    #memory-mini .card {
      width: 100px;
      height: 100px;
      background: var(--card);
      border: 1px solid var(--grid);
      display: grid;
      place-items: center;
      font-size: 20px;
      cursor: pointer;
      border-radius: 8px;
      color: var(--ink);
      -webkit-user-select: none;
      user-select: none;
      transition: transform 0.12s ease, background-color 0.2s ease, border-color 0.2s ease;
    }
    #memory-mini .card:hover {
      border-color: var(--accent);
      transform: scale(1.02);
    }
    #memory-mini .card:active { transform: scale(0.98); }
    #memory-mini .card.matched {
      background: var(--accent);
      color: var(--bg);
      cursor: default;
      border-color: var(--accent);
    }
    #memory-mini .side {
      display: grid;
      gap: 10px;
      align-content: start;
      justify-items: center;
      min-width: 180px;
    }
    #memory-mini .pill {
      border: 1px solid var(--grid);
      border-radius: 12px;
      padding: 8px 14px;
      font-size: 1rem;
      background: var(--card);
      width: 100%;
      text-align: center;
      color: var(--ink);
    }
    #memory-mini #startbtn {
      padding: 10px 16px;
      background: var(--card);
      color: var(--ink);
      border: 1px solid var(--grid);
      font-weight: 700;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    #memory-mini #startbtn:hover {
      border-color: var(--accent);
      transform: scale(1.05);
      box-shadow: 0 0 12px var(--accent);
    }
    #memory-mini #startbtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Responsive */
    @media (max-width: 480px) {
      #memory-mini #game-container {
        grid-template-columns: repeat(4, 72px);
        gap: 8px;
      }
      #memory-mini .card {
        width: 72px; height: 72px;
        font-size: 16px;
      }
    }
  </style>

  <!-- Memory Game HTML -->
  <section id="memory-mini" aria-label="Colorful Memory Match Game">
    <div class="wrap">
      <h2>Colorful Memory Match Game</h2>
      <div class="box">
        <div id="game-container" aria-live="polite" aria-label="Game board">
          <!-- Cards are injected by JS -->
        </div>
        <aside class="side">
          <p id="score" class="pill" aria-live="polite">Score: 0</p>
          <p id="timer" class="pill" aria-live="polite">Time Left: 10</p>
          <button id="startbtn">Start / Restart</button>
        </aside>
      </div>
    </div>
  </section>

  <script>
    (function () {
      // Keep original behavior: 12 entries, then duplicated -> 24 cards (4 of each color)
      const base = ['red','blue','green','purple','orange','pink','red','blue','green','purple','orange','pink'];
      let cards = shuffle(base.concat(base)); // 24
      let selected = [];
      let score = 0;
      let timer = 10;
      let ticking = null;
      let lockBoard = false; // prevent rapid clicking while checking

      const btn   = document.getElementById('startbtn');
      const grid  = document.getElementById('game-container');
      const elScore = document.getElementById('score');
      const elTimer = document.getElementById('timer');

      function showGameMessage(title, subtitle, emoji) {
        const overlay = document.createElement('div');
        overlay.className = 'game-message-overlay';
        overlay.innerHTML = `
          <div class="game-message-box">
            <div class="game-message-title">${emoji} ${title}</div>
            <div class="game-message-subtitle">${subtitle}</div>
            <button class="game-message-button" onclick="this.closest('.game-message-overlay').remove()">OK</button>
          </div>
        `;
        document.body.appendChild(overlay);
        
        // If victory, add confetti
        if (title.includes('Victory') || title.includes('Win')) {
          createConfetti();
        }
      }

      function createConfetti() {
        const colors = ['#ff8c42', '#ffb347', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f7dc6f', '#bb8fce'];
        for (let i = 0; i < 50; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animationDelay = Math.random() * 0.5 + 's';
            confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 3000);
          }, i * 30);
        }
      }

      function renderCards() {
        grid.innerHTML = '';
        for (const color of cards) {
          const card = document.createElement('div');
          card.className = 'card';
          card.dataset.color = color;
          card.textContent = '?';
          grid.appendChild(card);
        }
      }

      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function handleCardClick(e) {
        const card = e.target;
        if (!card.classList.contains('card')) return;
        if (card.classList.contains('matched')) return;
        if (lockBoard) return;

        // prevent selecting the same card twice
        if (selected.length === 1 && selected[0] === card) return;

        card.textContent = card.dataset.color;
        card.style.backgroundColor = card.dataset.color;
        selected.push(card);

        if (selected.length === 2) {
          lockBoard = true;
          setTimeout(checkMatch, 450);
        }
      }

      function checkMatch() {
        const [a, b] = selected;
        if (a && b && a.dataset.color === b.dataset.color) {
          a.classList.add('matched');
          b.classList.add('matched');
          score += 2;
          elScore.textContent = 'Score: ' + score;
        } else {
          // flip back
          if (a) { a.textContent = '?'; a.style.backgroundColor = ''; }
          if (b) { b.textContent = '?'; b.style.backgroundColor = ''; }
        }
        selected = [];
        lockBoard = false;

        // Check if all matched
        const remaining = grid.querySelectorAll('.card:not(.matched)').length;
        if (remaining === 0) {
          stopTimer();
          btn.disabled = false;
          setTimeout(() => {
            showGameMessage('Victory!', `You matched all cards! Final Score: ${score}`, 'üéâ');
          }, 500);
        }
      }

      function start() {
        // reset state
        stopTimer();
        // Base 10 seconds + collected leaves
        var leafCount = window.leafCollectedCount || 0;
        timer = 10 + leafCount;
        elTimer.textContent = 'Time Left: ' + timer;
        score = 0;
        elScore.textContent = 'Score: ' + score;
        btn.disabled = true;
        selected = [];
        lockBoard = false;
        cards = shuffle(base.concat(base));
        renderCards();

        // listener attached once globally; no duplicates
        tick();
      }

      // Expose a tiny API so leaves can add time safely
      window.colorfulMemory = {
        addTime(sec = 1) {
          try {
            if (typeof sec !== 'number') sec = 1;
          } catch(e){ sec = 1; }
          if (typeof elTimer !== 'undefined' && typeof timer !== 'undefined') {
            timer += sec;
            if (timer < 0) timer = 0;
            elTimer.textContent = 'Time Left: ' + timer;
          }
        }
      };

      function tick() {
        ticking = setInterval(() => {
          timer--;
          elTimer.textContent = 'Time Left: ' + timer;
          if (timer <= 0) {
            stopTimer();
            btn.disabled = false;
            showGameMessage('Game Over!', 'Time ran out! Try again.', '‚è±Ô∏è');
          }
        }, 1000);
      }

      function stopTimer() {
        if (ticking) clearInterval(ticking);
        ticking = null;
      }

      // Attach listeners (once)
      grid.addEventListener('click', handleCardClick);
      btn.addEventListener('click', start);

      // First render (board is empty until Start)
      renderCards();
    })();
  </script>


  <script>
    // ===== State =====
    class Player {
      constructor(name){
        this.name = name;
        this.roundsWon = 0;    // 0 until they win once
        this.balance = 0;
        this.guesses = [];     // per round index
        this.winningRounds = [];
      }
      makeGuess(n){ this.guesses.push(n); }
      lastGuess(){ return this.guesses[this.guesses.length-1]; }
    }

    let players = [];
    let roundNumber = 1;
  let finalMode = false; // when true: only the last remaining player guesses
  // Tie-break (lowest duplicate) mode state
  let tieMode = false;          // true while resolving a lowest-guess tie
  let tiePlayers = [];          // subset of players currently in tie-break
  // For tieMode: enforce newGuess < previous guess for those still tied
  const tieConstraint = new Map(); // player -> previous (current lowest tied) guess

    // ===== Autumn Leaves Animation =====
    function spawnLeaves(count=20){
      const container=document.getElementById('leaves');
      if(!container) return;
      for(let i=0;i<count;i++) addLeaf(container);
    }
    const glyphs=["üçÅ","üçÇ","üçÉ"];
    function rand(min,max){return Math.random()*(max-min)+min}
    function addLeaf(container){
      const leaf=document.createElement('span');
      leaf.className='leaf';
      const drift=document.createElement('span');
      drift.className='drift';
      const spin=document.createElement('span');
      spin.className='spin';
      spin.textContent=glyphs[Math.floor(Math.random()*glyphs.length)];
      drift.appendChild(spin); leaf.appendChild(drift);

      leaf.style.left = rand(-5, 105) + '%';
      leaf.style.setProperty('--fallDur', rand(15, 25) + 's');
      leaf.style.setProperty('--driftDur', rand(4, 8) + 's');
      leaf.style.setProperty('--spinDur', rand(3, 6) + 's');
      leaf.style.animationDelay = rand(0, 5) + 's';
      container.appendChild(leaf);
        }

        // Initialize falling leaves when page loads
        document.addEventListener('DOMContentLoaded', () => {
      spawnLeaves(30); // Add 21 falling leaves
    });

    // ===== DOM helpers =====
    const $ = s => document.querySelector(s);
    const show = (sel, on=true) => {
      const el = typeof sel==="string" ? $(sel) : sel;
      if(!el) return; el.classList[on ? "remove":"add"]("hidden");
    };
    const log = (msg, level="") => {
      const out = $("#output");
      const prefix = level==="ok"?"‚úÖ ":level==="warn"?"‚ö†Ô∏è ":level==="err"?"‚õî ":"";
      out.textContent += `${prefix}${msg}\n`;
      out.scrollTop = out.scrollHeight;
    };

    // ===== UI bindings =====
    $("#btnInstructions").addEventListener("click", () => {
      const hidden = $("#instructions").classList.contains("hidden");
      show("#instructions", hidden);
      $("#btnInstructions").textContent = hidden ? "Hide Instructions" : "Show Instructions";
    });
    $("#btnRestartTop").addEventListener("click", restartGame);
    $("#btnSetupPlayers").addEventListener("click", setupPlayers);
    $("#btnStart").addEventListener("click", startGame);
    $("#btnPlay").addEventListener("click", playRound);
    $("#btnReenter").addEventListener("click", () => setupRound(true));

    // ===== Chart setup =====
    let chart;
    function palette(n){
      const base = [
        "#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f","#edc949",
        "#af7aa1","#ff9da7","#9c755f","#bab0ab","#86b1f2","#f4a259",
        "#c75146","#2ca58d","#8ab17d","#b07aa1","#7f7fff","#00bcd4",
        "#ffd166","#06d6a0","#ef476f"
      ];
      const out=[]; for(let i=0;i<n;i++) out.push(base[i%base.length]);
      return out;
    }
    function ensureChart(){
      const ctx = $("#guessChart");
      if(chart) return chart;
      chart = new Chart(ctx, {
        type: "line",
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: "bottom", labels: { color: "#e9ecff" } },
            tooltip: { intersect:false, mode:"nearest" }
          },
          scales: {
            x: { ticks:{ color:"#9aa2d0" }, grid:{ color:"#243056" }, title:{ display:true, text:"Round", color:"#9aa2d0" } },
            y: { beginAtZero:true, ticks:{ color:"#9aa2d0" }, grid:{ color:"#243056" }, title:{ display:true, text:"Guess", color:"#9aa2d0" } }
          },
          elements:{ line:{ tension:0.25 }, point:{ radius:3 } }
        }
      });
      return chart;
    }
    function updateChart(){
      const c = ensureChart();
      const maxRounds = Math.max(1, ...players.map(p => p.guesses.length));
      c.data.labels = Array.from({length:maxRounds}, (_,i)=> `R${i+1}`);
      const colors = palette(players.length);
      c.data.datasets = players.map((p, idx) => ({
        label: p.name,
        data: Array.from({length:maxRounds}, (_,i)=> p.guesses[i] ?? null),
        borderColor: colors[idx],
        backgroundColor: colors[idx],
        spanGaps: true
      }));
      c.update();
    }

    // ===== Flow =====
    function setupPlayers(){
      const num = parseInt($("#numPlayers").value,10);
      if(!Number.isInteger(num) || num<2 || num>100){
        log("Please enter a valid number of players (2‚Äì100).","warn"); return;
      }
      const form=$("#playerForm");
      form.innerHTML="";
      for(let i=0;i<num;i++){
        const row=document.createElement("div");
        row.innerHTML=`
          <label>Player ${i+1} Name</label>
          <input type="text" id="player${i}" placeholder="Name" required />
        `;
        form.appendChild(row);
      }
      show("#player-setup", false);
      show("#player-names", true);
    }

    function startGame(){
      const inputs=[...document.querySelectorAll("#playerForm input")];
      const names=inputs.map(i => (i.value||"").trim());
      if(names.some(n => n.length===0)){
        log("Please fill all player names.","warn"); return;
      }
      players=names.map(n => new Player(n));
      roundNumber=1;
  finalMode=false;
  tieMode=false;
  tiePlayers=[];
  tieConstraint.clear();

      show("#player-names", false);
      show("#game", true);
      show("#logwrap", true);
      show("#round-buttons", true);
      setupRound();
      updateChart();
    }

    function setupRound(reenter=false){
      const baseEligible = players.filter(p => p.roundsWon === 0);
      finalMode = !tieMode && baseEligible.length === 1; // no tie-break in progress

      $("#round-info").textContent = finalMode ? `Final Round (Round ${roundNumber})` : `Round ${roundNumber}`;

      if(finalMode){
        $("#round-note").textContent = `Only ${baseEligible[0].name} chooses a guess this round. All players still pay the winning amount.`;
      } else if(tieMode){
        const currentLowest = tiePlayers.length ? tiePlayers[0].lastGuess() : "?";
        $("#round-note").textContent = `Tie-break: only tied lowest players re-enter with a bet lower than ${currentLowest}.`;
      } else {
        $("#round-note").textContent = `Only players who haven‚Äôt won yet may guess.`;
      }

      const g=$("#guesses"); g.innerHTML="";
      const toPrompt = tieMode ? tiePlayers : baseEligible;

      toPrompt.forEach((p, i) => {
        const prev = p.lastGuess();
        const needsLower = tieMode && tieConstraint.has(p);
        const maxAttr = needsLower && Number.isFinite(prev) ? `max="${prev-1}"` : "";
        const hint = needsLower && Number.isFinite(prev) ? `<div class="hint">New bet must be &lt; ${prev}</div>` : "";
        const row=document.createElement("div");
        row.className="row";
        row.innerHTML=`
          <div><b>${p.name}</b>‚Äôs guess ${hint}</div>
          <input type="number" step="1" min="0" ${maxAttr} id="guess${i}" placeholder="e.g. 7" required />
        `;
        g.appendChild(row);
      });

      // Disable buttons initially until all guesses are entered
      $("#btnPlay").disabled = true;
      $("#btnReenter").disabled = true;

      // Add input listeners to enable buttons when all fields are filled
      const guessInputs = document.querySelectorAll("#guesses input");
      guessInputs.forEach(input => {
        input.addEventListener('input', checkAllGuessesEntered);
      });

      if(!reenter){ renderScoreboard(); }
    }

    function checkAllGuessesEntered() {
      const inputs = [...document.querySelectorAll("#guesses input")];
      const allFilled = inputs.length > 0 && inputs.every(i => i.value.trim() !== "");
      $("#btnPlay").disabled = !allFilled;
      $("#btnReenter").disabled = !allFilled;
    }

    function playRound(){
      const baseEligible = players.filter(p => p.roundsWon === 0);
      const activeEligible = tieMode ? tiePlayers : baseEligible;
      const inputs=[...document.querySelectorAll("#guesses input")];

      // Collect guesses
      const submitted=[];
      for(let i=0;i<inputs.length;i++){
        const raw=inputs[i].value.trim();
        if(raw===""){ log(`Missing guess for ${activeEligible[i].name}.`,`warn`); return; }
        const val=Number(raw);
        if(!Number.isInteger(val) || val<0){ log(`${activeEligible[i].name} must enter a non-negative integer.`,`warn`); return; }

        if(tieMode){
          const prevLimit = tieConstraint.get(activeEligible[i]);
            // previous baseline they must go below
          if(!(val < prevLimit)){
            log(`${activeEligible[i].name}: new bet must be lower than your previous tied bet (${prevLimit}).`,`err`); return;
          }
          // Replace last guess (do not extend rounds)
          activeEligible[i].guesses[activeEligible[i].guesses.length-1] = val;
        } else {
          activeEligible[i].makeGuess(val);
        }
        submitted.push(val);
      }

      let winner, winningGuess;

      if(finalMode){
        winner = activeEligible[0];
        winningGuess = winner.lastGuess() ?? 0;
      } else if(tieMode){
        // Evaluate tie-break iteration among current tie players
        const minNow = Math.min(...tiePlayers.map(p => p.lastGuess()));
        const stillTied = tiePlayers.filter(p => p.lastGuess() === minNow);
        if(stillTied.length > 1){
          // Continue tie-break with only those still tied
            tiePlayers = stillTied;
            tieConstraint.clear();
            for(const p of tiePlayers){ tieConstraint.set(p, p.lastGuess()); }
            log(`üîÅ Still tied at ${minNow}. Only tied players re-enter with a lower bet.`, "warn");
            setupRound(true);
            return;
        } else {
          // Tie resolved
          winner = stillTied[0];
          winningGuess = winner.lastGuess();
          tieMode = false;
          tiePlayers = [];
          tieConstraint.clear();
        }
      } else {
        // Normal round resolution
        const minGuess = Math.min(...submitted);
        const minPlayers = activeEligible.filter(p => p.lastGuess() === minGuess);
        if(minPlayers.length > 1){
          // Initiate tie-break with only those at lowest
          tieMode = true;
          tiePlayers = minPlayers;
          tieConstraint.clear();
          for(const p of tiePlayers){ tieConstraint.set(p, p.lastGuess()); }
          for(const p of tiePlayers){
            log(`üîÅ ${p.name}: tied lowest at ${minGuess} ‚Äî enter a new lower bet.`, "warn");
          }
          setupRound(true);
          return;
        }
        winner = minPlayers[0];
        winningGuess = minGuess;
      }

      // Payments: everyone pays winningGuess; winner receives pot
      const totalPlayers = players.length;
      for(const p of players){ p.balance -= winningGuess; }
      winner.balance += winningGuess * totalPlayers;

      // Mark win (only once)
      if(winner.roundsWon === 0){
        winner.roundsWon = 1;
        winner.winningRounds.push(roundNumber);
      }

      const modeLabel = finalMode ? "Final round" : `Round ${roundNumber}`;
      log(`üèÜ ${modeLabel} winner: ${winner.name} ‚Äî winning guess ${winningGuess}.`, "ok");
      log(`‚û°Ô∏è Everyone pays ‚Ç¨${winningGuess}. ${winner.name} receives ‚Ç¨${winningGuess * totalPlayers}.`, "ok");

      roundNumber++;
      updateChart();

      const remaining = players.filter(p => p.roundsWon === 0);

      if(finalMode){
        finishGame();
        return;
      }
      if(remaining.length === 1){
        setupRound(false); // will flip to finalMode next time
        return;
      }
      setupRound(false);
    }

    function renderScoreboard(){
      const el=$("#scoreboard");
      const rows = players.map(p =>
        `<tr>
          <td>${escapeHtml(p.name)}</td>
          <td>${p.roundsWon}</td>
          <td>${p.balance}</td>
          <td>${p.winningRounds.length ? p.winningRounds[0] : "-"}</td>
        </tr>`
      ).join("");
      el.innerHTML = `
        <div class="scoreboard">
          <table>
            <thead><tr><th>Player</th><th>Rounds Won</th><th>Balance (‚Ç¨)</th><th>Winning round</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    }

    function finishGame(){
      // Chronological recap
      const ordered = players.slice().sort((a,b)=>{
        const af = a.winningRounds[0] ?? Infinity;
        const bf = b.winningRounds[0] ?? Infinity;
        return af - bf;
      });

      log(`\nüèÅ Game Finished\n`, "ok");
      for(const p of ordered){
        const wr = p.winningRounds.length ? p.winningRounds[0] : "None";
        log(`‚Ä¢ ${p.name} ‚Äî Balance: ‚Ç¨${p.balance} | Winning round: ${wr}`);
      }

      renderScoreboard();
      show("#game", false);
      show("#game-finished", true);
    }

    function restartGame(){
  players=[]; roundNumber=1; finalMode=false; tieMode=false; tiePlayers=[]; tieConstraint.clear();
      $("#output").textContent="";
      $("#numPlayers").value="";
      $("#playerForm").innerHTML="";
      $("#guesses").innerHTML="";
      $("#round-info").textContent="";
      $("#round-note").textContent="";
      $("#scoreboard").innerHTML="";
      if(chart){ chart.destroy(); chart=null; }
      show("#game", false);
      show("#logwrap", false);
      show("#game-finished", false);
      show("#player-names", false);
      show("#player-setup", true);
    }

    function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  </script>

  <script>
    // Global leaf collection counter
    window.leafCollectedCount = 0;
    
    // Click-to-catch: each leaf adds +1s to the memory timer and is removed
    (function(){
      var leavesRoot = document.getElementById('leaves');
      var leafCountEl = document.getElementById('leaf-count');
      if (!leavesRoot) return;
      
      function showBonus(x, y) {
        var bonus = document.createElement('div');
        bonus.className = 'time-bonus';
        bonus.textContent = '+1s ‚è±Ô∏è';
        bonus.style.left = x + 'px';
        bonus.style.top = y + 'px';
        document.body.appendChild(bonus);
        setTimeout(function(){ 
          if (bonus && bonus.parentNode) bonus.parentNode.removeChild(bonus); 
        }, 1000);
      }
      
      leavesRoot.addEventListener('click', function(e){
        var leaf = e.target.closest ? e.target.closest('.leaf') : null;
        if (!leaf || leaf.classList.contains('captured')) return;
        
        // Get click position
        var rect = leaf.getBoundingClientRect();
        var x = rect.left + rect.width / 2;
        var y = rect.top + rect.height / 2;
        
        leaf.classList.add('captured');
        showBonus(x, y);
        
        // Increment collected leaf count
        window.leafCollectedCount++;
        if (leafCountEl) {
          leafCountEl.textContent = window.leafCollectedCount;
        }
        
        // If memory game is running, add time to it
        if (window.colorfulMemory && typeof window.colorfulMemory.addTime === 'function') {
          window.colorfulMemory.addTime(1);
        }
        
        setTimeout(function(){ if (leaf && leaf.parentNode) leaf.parentNode.removeChild(leaf); }, 400);
      });
    })();
  </script>
</body>
</html>
