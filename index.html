<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skyline ‚Äì Offline Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root { --bg:#0f1222; --card:#171a2b; --ink:#e9ecff; --muted:#9aa2d0; --accent:#7cf; --grid:#243056; }
    *{box-sizing:border-box}
    body{margin:0;padding:24px;color:var(--ink);background:linear-gradient(180deg,#0a0d1a,#0f1222 35%,#0a0d1a);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,"Noto Sans",Arial,sans-serif}
    h1{font-family:"Press Start 2P",monospace;font-size:20px;text-align:center;margin:0 0 16px}
    .flex-header{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-bottom:12px}
    button{background:var(--card);border:1px solid #2a2f4b;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
    button:hover{border-color:var(--accent)}
    .card{max-width:980px;margin:12px auto;background:var(--card);border:1px solid #202544;border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
    label{display:block;margin:10px 0 6px;color:var(--muted)}
    input[type="number"],input[type="text"]{width:100%;background:#0e1020;color:var(--ink);border:1px solid #2a2f4b;border-radius:10px;padding:10px}
    #instructions ul{margin:8px 0 0 18px}
    #round-info{font-weight:700;margin-bottom:4px}
    #round-note{color:var(--muted);margin-bottom:8px}
    #guesses .row{display:grid;grid-template-columns:1fr 200px;gap:10px;align-items:center;margin:8px 0}
    .hint{font-size:12px;color:#ffd580}
    #output{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;color:#cfe3ff;margin-top:10px}
    .scoreboard table{width:100%;border-collapse:collapse;margin-top:8px}
    .scoreboard th,.scoreboard td{padding:8px;border-bottom:1px solid #273057;text-align:left;font-size:14px}
    .ok{color:#98f5a9}.warn{color:#ffd580}.err{color:#ff9aa2}
    .hidden{display:none !important}
    .flag{font-size:20px}
    canvas{background:#0e1020;border:1px solid var(--grid);border-radius:12px}
  </style>
</head>
<body>
  <h1>üåü Skyline: Web-App üåü</h1>

  <div class="flex-header">
    <button id="btnInstructions">Show Instructions</button>
    <button id="btnRestartTop">Restart Game</button>
  </div>

  <div id="instructions" class="card hidden">
    <p>üéØ <b>Rules</b></p>
    <ul>
      <li>Only players who haven‚Äôt won yet make a guess each round.</li>
      <li>The <b>lowest unique</b> guess among eligible players wins the round.</li>
      <li>Each player can win only once.</li>
      <li><b>Payments each round:</b> everyone (including the winner) pays the winning guess; the winner receives the total pot.</li>
      <li>When only one player hasn‚Äôt won, an <b>extra final round</b> runs where that last player chooses a bet; then the game <b>finishes</b> üèÅ.</li>
  <li>If two or more players tie for the <b>lowest guess</b>, only those tied players must re-enter with a bet <b>lower than their previous bet</b>. This repeats until a single lowest guess remains (the winner).</li>
    </ul>
  </div>

  <div id="player-setup" class="card">
    <label for="numPlayers">Enter Number of Players (2‚Äì100)</label>
    <input type="number" id="numPlayers" min="2" max="100" />
    <div style="margin-top:10px"><button id="btnSetupPlayers">Next</button></div>
  </div>

  <div id="player-names" class="card hidden">
    <form id="playerForm"></form>
    <div style="margin-top:10px"><button id="btnStart">Start Game</button></div>
  </div>

  <div id="game" class="card hidden">
    <div id="round-info"></div>
    <div id="round-note"></div>
    <div id="guesses"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 0">
      <button id="btnPlay">Play Round</button>
      <button id="btnReenter">Re-enter Guesses</button>
    </div>

    <div class="scoreboard" id="scoreboard" style="margin-top:12px"></div>
  </div>

  <!-- Graph + Game Log together -->
  <div id="logwrap" class="card hidden">
    <canvas id="guessChart" height="220"></canvas>
    <div style="color:#9aa2d0;margin:10px 0 6px">Game Log</div>
    <pre id="output"></pre>
  </div>

  <div id="game-finished" class="card hidden">
    <div class="ok"><span class="flag">üèÅ</span> <b>Game Finished</b></div>
    <div class="warn">Use ‚ÄúRestart Game‚Äù above to play again.</div>
  </div>

  <script>
    // ===== State =====
    class Player {
      constructor(name){
        this.name = name;
        this.roundsWon = 0;    // 0 until they win once
        this.balance = 0;
        this.guesses = [];     // per round index
        this.winningRounds = [];
      }
      makeGuess(n){ this.guesses.push(n); }
      lastGuess(){ return this.guesses[this.guesses.length-1]; }
    }

    let players = [];
    let roundNumber = 1;
  let finalMode = false; // when true: only the last remaining player guesses
  // Tie-break (lowest duplicate) mode state
  let tieMode = false;          // true while resolving a lowest-guess tie
  let tiePlayers = [];          // subset of players currently in tie-break
  // For tieMode: enforce newGuess < previous guess for those still tied
  const tieConstraint = new Map(); // player -> previous (current lowest tied) guess

    // ===== DOM helpers =====
    const $ = s => document.querySelector(s);
    const show = (sel, on=true) => {
      const el = typeof sel==="string" ? $(sel) : sel;
      if(!el) return; el.classList[on ? "remove":"add"]("hidden");
    };
    const log = (msg, level="") => {
      const out = $("#output");
      const prefix = level==="ok"?"‚úÖ ":level==="warn"?"‚ö†Ô∏è ":level==="err"?"‚õî ":"";
      out.textContent += `${prefix}${msg}\n`;
      out.scrollTop = out.scrollHeight;
    };

    // ===== UI bindings =====
    $("#btnInstructions").addEventListener("click", () => {
      const hidden = $("#instructions").classList.contains("hidden");
      show("#instructions", hidden);
      $("#btnInstructions").textContent = hidden ? "Hide Instructions" : "Show Instructions";
    });
    $("#btnRestartTop").addEventListener("click", restartGame);
    $("#btnSetupPlayers").addEventListener("click", setupPlayers);
    $("#btnStart").addEventListener("click", startGame);
    $("#btnPlay").addEventListener("click", playRound);
    $("#btnReenter").addEventListener("click", () => setupRound(true));

    // ===== Chart setup =====
    let chart;
    function palette(n){
      const base = [
        "#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f","#edc949",
        "#af7aa1","#ff9da7","#9c755f","#bab0ab","#86b1f2","#f4a259",
        "#c75146","#2ca58d","#8ab17d","#b07aa1","#7f7fff","#00bcd4",
        "#ffd166","#06d6a0","#ef476f"
      ];
      const out=[]; for(let i=0;i<n;i++) out.push(base[i%base.length]);
      return out;
    }
    function ensureChart(){
      const ctx = $("#guessChart");
      if(chart) return chart;
      chart = new Chart(ctx, {
        type: "line",
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: "bottom", labels: { color: "#e9ecff" } },
            tooltip: { intersect:false, mode:"nearest" }
          },
          scales: {
            x: { ticks:{ color:"#9aa2d0" }, grid:{ color:"#243056" }, title:{ display:true, text:"Round", color:"#9aa2d0" } },
            y: { beginAtZero:true, ticks:{ color:"#9aa2d0" }, grid:{ color:"#243056" }, title:{ display:true, text:"Guess", color:"#9aa2d0" } }
          },
          elements:{ line:{ tension:0.25 }, point:{ radius:3 } }
        }
      });
      return chart;
    }
    function updateChart(){
      const c = ensureChart();
      const maxRounds = Math.max(1, ...players.map(p => p.guesses.length));
      c.data.labels = Array.from({length:maxRounds}, (_,i)=> `R${i+1}`);
      const colors = palette(players.length);
      c.data.datasets = players.map((p, idx) => ({
        label: p.name,
        data: Array.from({length:maxRounds}, (_,i)=> p.guesses[i] ?? null),
        borderColor: colors[idx],
        backgroundColor: colors[idx],
        spanGaps: true
      }));
      c.update();
    }

    // ===== Flow =====
    function setupPlayers(){
      const num = parseInt($("#numPlayers").value,10);
      if(!Number.isInteger(num) || num<2 || num>100){
        log("Please enter a valid number of players (2‚Äì100).","warn"); return;
      }
      const form=$("#playerForm");
      form.innerHTML="";
      for(let i=0;i<num;i++){
        const row=document.createElement("div");
        row.innerHTML=`
          <label>Player ${i+1} Name</label>
          <input type="text" id="player${i}" placeholder="Name" required />
        `;
        form.appendChild(row);
      }
      show("#player-setup", false);
      show("#player-names", true);
    }

    function startGame(){
      const inputs=[...document.querySelectorAll("#playerForm input")];
      const names=inputs.map(i => (i.value||"").trim());
      if(names.some(n => n.length===0)){
        log("Please fill all player names.","warn"); return;
      }
      players=names.map(n => new Player(n));
      roundNumber=1;
  finalMode=false;
  tieMode=false;
  tiePlayers=[];
  tieConstraint.clear();

      show("#player-names", false);
      show("#game", true);
      show("#logwrap", true);
      setupRound();
      updateChart();
    }

    function setupRound(reenter=false){
      const baseEligible = players.filter(p => p.roundsWon === 0);
      finalMode = !tieMode && baseEligible.length === 1; // no tie-break in progress

      $("#round-info").textContent = finalMode ? `Final Round (Round ${roundNumber})` : `Round ${roundNumber}`;

      if(finalMode){
        $("#round-note").textContent = `Only ${baseEligible[0].name} chooses a guess this round. All players still pay the winning amount.`;
      } else if(tieMode){
        const currentLowest = tiePlayers.length ? tiePlayers[0].lastGuess() : "?";
        $("#round-note").textContent = `Tie-break: only tied lowest players re-enter with a bet lower than ${currentLowest}.`;
      } else {
        $("#round-note").textContent = `Only players who haven‚Äôt won yet may guess.`;
      }

      const g=$("#guesses"); g.innerHTML="";
      const toPrompt = tieMode ? tiePlayers : baseEligible;

      toPrompt.forEach((p, i) => {
        const prev = p.lastGuess();
        const needsLower = tieMode && tieConstraint.has(p);
        const maxAttr = needsLower && Number.isFinite(prev) ? `max="${prev-1}"` : "";
        const hint = needsLower && Number.isFinite(prev) ? `<div class="hint">New bet must be &lt; ${prev}</div>` : "";
        const row=document.createElement("div");
        row.className="row";
        row.innerHTML=`
          <div><b>${p.name}</b>‚Äôs guess ${hint}</div>
          <input type="number" step="1" min="0" ${maxAttr} id="guess${i}" placeholder="e.g. 7" required />
        `;
        g.appendChild(row);
      });

      if(!reenter){ renderScoreboard(); }
    }

    function playRound(){
      const baseEligible = players.filter(p => p.roundsWon === 0);
      const activeEligible = tieMode ? tiePlayers : baseEligible;
      const inputs=[...document.querySelectorAll("#guesses input")];

      // Collect guesses
      const submitted=[];
      for(let i=0;i<inputs.length;i++){
        const raw=inputs[i].value.trim();
        if(raw===""){ log(`Missing guess for ${activeEligible[i].name}.`,`warn`); return; }
        const val=Number(raw);
        if(!Number.isInteger(val) || val<0){ log(`${activeEligible[i].name} must enter a non-negative integer.`,`warn`); return; }

        if(tieMode){
          const prevLimit = tieConstraint.get(activeEligible[i]);
            // previous baseline they must go below
          if(!(val < prevLimit)){
            log(`${activeEligible[i].name}: new bet must be lower than your previous tied bet (${prevLimit}).`,`err`); return;
          }
          // Replace last guess (do not extend rounds)
          activeEligible[i].guesses[activeEligible[i].guesses.length-1] = val;
        } else {
          activeEligible[i].makeGuess(val);
        }
        submitted.push(val);
      }

      let winner, winningGuess;

      if(finalMode){
        winner = activeEligible[0];
        winningGuess = winner.lastGuess() ?? 0;
      } else if(tieMode){
        // Evaluate tie-break iteration among current tie players
        const minNow = Math.min(...tiePlayers.map(p => p.lastGuess()));
        const stillTied = tiePlayers.filter(p => p.lastGuess() === minNow);
        if(stillTied.length > 1){
          // Continue tie-break with only those still tied
            tiePlayers = stillTied;
            tieConstraint.clear();
            for(const p of tiePlayers){ tieConstraint.set(p, p.lastGuess()); }
            log(`üîÅ Still tied at ${minNow}. Only tied players re-enter with a lower bet.`, "warn");
            setupRound(true);
            return;
        } else {
          // Tie resolved
          winner = stillTied[0];
          winningGuess = winner.lastGuess();
          tieMode = false;
          tiePlayers = [];
          tieConstraint.clear();
        }
      } else {
        // Normal round resolution
        const minGuess = Math.min(...submitted);
        const minPlayers = activeEligible.filter(p => p.lastGuess() === minGuess);
        if(minPlayers.length > 1){
          // Initiate tie-break with only those at lowest
          tieMode = true;
          tiePlayers = minPlayers;
          tieConstraint.clear();
          for(const p of tiePlayers){ tieConstraint.set(p, p.lastGuess()); }
          for(const p of tiePlayers){
            log(`üîÅ ${p.name}: tied lowest at ${minGuess} ‚Äî enter a new lower bet.`, "warn");
          }
          setupRound(true);
          return;
        }
        winner = minPlayers[0];
        winningGuess = minGuess;
      }

      // Payments: everyone pays winningGuess; winner receives pot
      const totalPlayers = players.length;
      for(const p of players){ p.balance -= winningGuess; }
      winner.balance += winningGuess * totalPlayers;

      // Mark win (only once)
      if(winner.roundsWon === 0){
        winner.roundsWon = 1;
        winner.winningRounds.push(roundNumber);
      }

      const modeLabel = finalMode ? "Final round" : `Round ${roundNumber}`;
      log(`üèÜ ${modeLabel} winner: ${winner.name} ‚Äî winning guess ${winningGuess}.`, "ok");
      log(`‚û°Ô∏è Everyone pays ‚Ç¨${winningGuess}. ${winner.name} receives ‚Ç¨${winningGuess * totalPlayers}.`, "ok");

      roundNumber++;
      updateChart();

      const remaining = players.filter(p => p.roundsWon === 0);

      if(finalMode){
        finishGame();
        return;
      }
      if(remaining.length === 1){
        setupRound(false); // will flip to finalMode next time
        return;
      }
      setupRound(false);
    }

    function renderScoreboard(){
      const el=$("#scoreboard");
      const rows = players.map(p =>
        `<tr>
          <td>${escapeHtml(p.name)}</td>
          <td>${p.roundsWon}</td>
          <td>${p.balance}</td>
          <td>${p.winningRounds.length ? p.winningRounds[0] : "-"}</td>
        </tr>`
      ).join("");
      el.innerHTML = `
        <div class="scoreboard">
          <table>
            <thead><tr><th>Player</th><th>Rounds Won</th><th>Balance (‚Ç¨)</th><th>Winning round</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    }

    function finishGame(){
      // Chronological recap
      const ordered = players.slice().sort((a,b)=>{
        const af = a.winningRounds[0] ?? Infinity;
        const bf = b.winningRounds[0] ?? Infinity;
        return af - bf;
      });

      log(`\nüèÅ Game Finished\n`, "ok");
      for(const p of ordered){
        const wr = p.winningRounds.length ? p.winningRounds[0] : "None";
        log(`‚Ä¢ ${p.name} ‚Äî Balance: ‚Ç¨${p.balance} | Winning round: ${wr}`);
      }

      renderScoreboard();
      show("#game", false);
      show("#game-finished", true);
    }

    function restartGame(){
  players=[]; roundNumber=1; finalMode=false; tieMode=false; tiePlayers=[]; tieConstraint.clear();
      $("#output").textContent="";
      $("#numPlayers").value="";
      $("#playerForm").innerHTML="";
      $("#guesses").innerHTML="";
      $("#round-info").textContent="";
      $("#round-note").textContent="";
      $("#scoreboard").innerHTML="";
      if(chart){ chart.destroy(); chart=null; }
      show("#game", false);
      show("#logwrap", false);
      show("#game-finished", false);
      show("#player-names", false);
      show("#player-setup", true);
    }

    function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  </script>
</body>
</html>
