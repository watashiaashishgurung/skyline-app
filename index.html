<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Skyline ‚Äì Offline Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root { --bg:#0f1222; --card:#171a2b; --ink:#e9ecff; --muted:#9aa2d0; --accent:#7cf; --grid:#243056; }
    *{box-sizing:border-box}
    body{margin:0;padding:24px;color:var(--ink);background:linear-gradient(180deg,#0a0d1a,#0f1222 35%,#0a0d1a);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,"Noto Sans",Arial,sans-serif}
    h1{font-family:"Press Start 2P",monospace;font-size:20px;text-align:center;margin:0 0 16px}
    .flex-header{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-bottom:12px}
    button{background:var(--card);border:1px solid #2a2f4b;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
    button:hover{border-color:var(--accent)}
    .card{max-width:980px;margin:12px auto;background:var(--card);border:1px solid #202544;border-radius:16px;padding:16px;box-shadow:0 6px 24px rgba(0,0,0,.35)}
    label{display:block;margin:10px 0 6px;color:var(--muted)}
    input[type="number"],input[type="text"]{width:100%;background:#0e1020;color:var(--ink);border:1px solid #2a2f4b;border-radius:10px;padding:10px}
    #instructions ul{margin:8px 0 0 18px}
    #round-info{font-weight:700;margin-bottom:4px}
    #round-note{color:var(--muted);margin-bottom:8px}
    #guesses .row{display:grid;grid-template-columns:1fr 200px;gap:10px;align-items:center;margin:8px 0}
    .hint{font-size:12px;color:#ffd580}
    #output{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;color:#cfe3ff;margin-top:10px}
    .scoreboard table{width:100%;border-collapse:collapse;margin-top:8px}
    .scoreboard th,.scoreboard td{padding:8px;border-bottom:1px solid #273057;text-align:left;font-size:14px}
    .ok{color:#98f5a9}.warn{color:#ffd580}.err{color:#ff9aa2}
    .hidden{display:none !important}
    .flag{font-size:20px}
    canvas{background:#0e1020;border:1px solid var(--grid);border-radius:12px}

    /* Smooth show/hide for cards */
    .card {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.4s ease;
    }
    .card:not(.hidden) {
      opacity: 1;
      transform: translateY(0);
    }

    /* Button hover pulse */
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 12px var(--accent);
      transition: all 0.2s ease;
    }

    /* Round info flip */
    #round-info {
      display: inline-block;
      animation: roundFlip 0.6s ease;
    }
    @keyframes roundFlip {
      from { transform: rotateX(90deg); opacity: 0; }
      to { transform: rotateX(0deg); opacity: 1; }
    }

    /* Log fade-in */
    #output {
      transition: all 0.3s ease;
    }
    #output span.new {
      animation: fadePop 0.5s ease;
    }
    @keyframes fadePop {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }

    /* Bubble Score Counter */
    #bubble-score {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--card);
      border: 1px solid #2a2f4b;
      border-radius: 12px;
      padding: 12px;
      z-index: 1000;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,.4);
    }
    
    #bubble-score .score-title {
      color: var(--accent);
      margin-bottom: 5px;
    }
    
    #bubble-score .score-line {
      color: var(--ink);
      margin: 3px 0;
    }
    
    #bubble-score .bubbles-left {
      color: var(--muted);
      font-size: 10px;
    }

    /* Multi-colored bubble animation */
    .bubbles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      overflow: hidden;
    }

    .bubble {
      position: absolute;
      border-radius: 50%;
      opacity: 0.7;
      animation: bubbleFloat 8s infinite linear;
      pointer-events: auto;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .bubble:hover {
      transform: scale(1.2);
      opacity: 0.9;
    }

    .bubble.popped {
      animation: bubblePop 0.4s ease-out forwards;
    }

    @keyframes bubblePop {
      0% {
        transform: scale(1);
        opacity: 0.7;
      }
      50% {
        transform: scale(1.5);
        opacity: 0.3;
      }
      100% {
        transform: scale(0);
        opacity: 0;
      }
    }

    .bubble:nth-child(1) { width: 20px; height: 20px; background: linear-gradient(45deg, #ff6b6b, #ff8e8e); animation-delay: 0s; left: 10%; }
    .bubble:nth-child(2) { width: 15px; height: 15px; background: linear-gradient(45deg, #4ecdc4, #44a08d); animation-delay: 1s; left: 20%; }
    .bubble:nth-child(3) { width: 25px; height: 25px; background: linear-gradient(45deg, #45b7d1, #96c93d); animation-delay: 2s; left: 30%; }
    .bubble:nth-child(4) { width: 18px; height: 18px; background: linear-gradient(45deg, #f093fb, #f5576c); animation-delay: 3s; left: 40%; }
    .bubble:nth-child(5) { width: 22px; height: 22px; background: linear-gradient(45deg, #ffecd2, #fcb69f); animation-delay: 4s; left: 50%; }
    .bubble:nth-child(6) { width: 16px; height: 16px; background: linear-gradient(45deg, #a8edea, #fed6e3); animation-delay: 5s; left: 60%; }
    .bubble:nth-child(7) { width: 30px; height: 30px; background: linear-gradient(45deg, #d299c2, #fef9d7); animation-delay: 6s; left: 70%; }
    .bubble:nth-child(8) { width: 12px; height: 12px; background: linear-gradient(45deg, #89f7fe, #66a6ff); animation-delay: 7s; left: 80%; }
    .bubble:nth-child(9) { width: 28px; height: 28px; background: linear-gradient(45deg, #fdbb2d, #22c1c3); animation-delay: 1.5s; left: 15%; }
    .bubble:nth-child(10) { width: 14px; height: 14px; background: linear-gradient(45deg, #ee9ca7, #ffdde1); animation-delay: 2.5s; left: 85%; }
    .bubble:nth-child(11) { width: 19px; height: 19px; background: linear-gradient(45deg, #667eea, #764ba2); animation-delay: 0.5s; left: 5%; }
    .bubble:nth-child(12) { width: 26px; height: 26px; background: linear-gradient(45deg, #f093fb, #f5576c); animation-delay: 3.5s; left: 25%; }

    @keyframes bubbleFloat {
      0% {
        bottom: -50px;
        transform: translateX(0) rotate(0deg);
        opacity: 0;
      }
      10% {
        opacity: 0.7;
      }
      90% {
        opacity: 0.7;
      }
      100% {
        bottom: 100vh;
        transform: translateX(100px) rotate(360deg);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <!-- Multi-colored bubble animation -->
  <div class="bubbles">
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
  </div>

  <h1>üåü Skyline: Web-App üåü</h1>

  <!-- Bubble Score Counter -->
  <div id="bubble-score">
    <div class="score-title">üéØ BUBBLE SCORE</div>
    <div class="score-line">Score: <span id="score-value">0</span></div>
    <div class="bubbles-left">Bubbles Left: <span id="bubbles-left">12</span></div>
  </div>

  <div class="flex-header">
    <button id="btnInstructions">Show Instructions</button>
    <button id="btnRestartTop">Restart Game</button>
  </div>

  <div id="instructions" class="card hidden">
    <p>üéØ <b>Rules</b></p>
    <ul>
      <li>Only players who haven‚Äôt won yet make a guess each round.</li>
      <li>The <b>lowest unique</b> guess among eligible players wins the round.</li>
      <li>Each player can win only once.</li>
      <li><b>Payments each round:</b> everyone (including the winner) pays the winning guess; the winner receives the total pot.</li>
      <li>When only one player hasn‚Äôt won, an <b>extra final round</b> runs where that last player chooses a bet; then the game <b>finishes</b> üèÅ.</li>
  <li>If two or more players tie for the <b>lowest guess</b>, only those tied players must re-enter with a bet <b>lower than their previous bet</b>. This repeats until a single lowest guess remains (the winner).</li>
    </ul>
  </div>

  <div id="player-setup" class="card">
    <label for="numPlayers">Enter Number of Players (2‚Äì100)</label>
    <input type="number" id="numPlayers" min="2" max="100" />
    <div style="margin-top:10px"><button id="btnSetupPlayers">Next</button></div>
  </div>

  <div id="player-names" class="card hidden">
    <form id="playerForm"></form>
    <div style="margin-top:10px"><button id="btnStart">Start Game</button></div>
  </div>

  <div id="game" class="card hidden">
    <div id="round-info"></div>
    <div id="round-note"></div>
    <div id="guesses"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 0">
      <button id="btnPlay">Play Round</button>
      <button id="btnReenter">Re-enter Guesses</button>
    </div>

    <div class="scoreboard" id="scoreboard" style="margin-top:12px"></div>
  </div>

  <!-- Graph + Game Log together -->
  <div id="logwrap" class="card hidden">
    <canvas id="guessChart" height="220"></canvas>
    <div style="color:#9aa2d0;margin:10px 0 6px">Game Log</div>
    <pre id="output"></pre>
  </div>

  <div id="game-finished" class="card hidden">
    <div class="ok"><span class="flag">üèÅ</span> <b>Game Finished</b></div>
    <div class="warn">Use ‚ÄúRestart Game‚Äù above to play again.</div>
  </div>

  <script>
    // ===== State =====
    class Player {
      constructor(name){
        this.name = name;
        this.roundsWon = 0;    // 0 until they win once
        this.balance = 0;
        this.guesses = [];     // per round index
        this.winningRounds = [];
      }
      makeGuess(n){ this.guesses.push(n); }
      lastGuess(){ return this.guesses[this.guesses.length-1]; }
    }

    let players = [];
    let roundNumber = 1;
  let finalMode = false; // when true: only the last remaining player guesses
  // Tie-break (lowest duplicate) mode state
  let tieMode = false;          // true while resolving a lowest-guess tie
  let tiePlayers = [];          // subset of players currently in tie-break
  // For tieMode: enforce newGuess < previous guess for those still tied
  const tieConstraint = new Map(); // player -> previous (current lowest tied) guess

    // ===== Bubble Interaction =====
    // Audio context for sound effects
    let audioContext;
    
    // Bubble scoring system
    let bubbleScore = 0;
    let poppedBubbles = new Set(); // Track which bubbles have been popped
    const totalBubbles = 12;
    
    // Points based on bubble size (smaller = more points)
    const bubblePoints = {
      12: 50,  // smallest bubbles = most points
      13: 45,
      14: 40,
      15: 35,
      16: 30,
      17: 25,
      18: 20,
      19: 15,
      20: 10,
      21: 10,
      22: 8,
      24: 8,
      25: 6,
      26: 6,
      28: 4,
      30: 2   // largest bubbles = least points
    };
    
    function updateScore(points) {
      bubbleScore += points;
      document.getElementById('score-value').textContent = bubbleScore;
      document.getElementById('bubbles-left').textContent = totalBubbles - poppedBubbles.size;
    }
    
    function getBubblePoints(bubbleElement) {
      const style = window.getComputedStyle(bubbleElement);
      const width = parseInt(style.width);
      return bubblePoints[width] || 10; // default points if size not found
    }
    
    function initAudio() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.log('Web Audio API not supported');
      }
    }
    
    function playPopSound() {
      if (!audioContext) return;
      
      // Create a pop sound effect
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      // Connect nodes
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      // Configure the pop sound
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
      
      // Volume envelope for pop effect
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
      
      // Start and stop the sound
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.1);
    }
    
    function playSparkleSound() {
      if (!audioContext) return;
      
      // Create a higher pitched sparkle sound
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      // Higher frequency for sparkle effect
      oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.05);
      oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.15);
      
      gainNode.gain.setValueAtTime(0, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.15);
    }

    function initBubbles() {
      const bubbles = document.querySelectorAll('.bubble');
      
      bubbles.forEach((bubble, index) => {
        bubble.addEventListener('click', function(e) {
          // Check if this bubble has already been popped
          if (poppedBubbles.has(index)) return;
          
          // Mark bubble as popped
          poppedBubbles.add(index);
          
          // Calculate and add points
          const points = getBubblePoints(this);
          updateScore(points);
          
          // Play pop sound
          playPopSound();
          
          // Add popped class for animation
          this.classList.add('popped');
          
          // Remove the bubble permanently after animation completes
          setTimeout(() => {
            this.remove();
            
            // Check if all bubbles are popped
            if (poppedBubbles.size === totalBubbles) {
              showGameComplete();
            }
          }, 400);
          
          // Show points popup
          createPointsEffect(e.clientX, e.clientY, points);
          createPopEffect(e.clientX, e.clientY);
        });
      });
    }

    function showGameComplete() {
      const completeDiv = document.createElement('div');
      completeDiv.innerHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                    background: var(--card); border: 2px solid var(--accent); border-radius: 16px; 
                    padding: 24px; z-index: 2000; text-align: center; font-family: 'Press Start 2P', monospace;">
          <div style="color: var(--accent); font-size: 16px; margin-bottom: 16px;">üéâ ALL BUBBLES POPPED! üéâ</div>
          <div style="color: var(--ink); margin-bottom: 12px;">Final Score: ${bubbleScore}</div>
          <div style="color: var(--muted); font-size: 10px; margin-bottom: 16px;">Refresh page to play again</div>
          <button onclick="location.reload()" style="background: var(--accent); color: #000; border: none; 
                         padding: 8px 16px; border-radius: 8px; cursor: pointer; font-family: inherit; font-size: 10px;">
            üîÑ Play Again
          </button>
        </div>
      `;
      document.body.appendChild(completeDiv);
    }

    function createPointsEffect(x, y, points) {
      const pointsDiv = document.createElement('div');
      pointsDiv.innerHTML = `+${points}`;
      pointsDiv.style.cssText = `
        position: fixed;
        left: ${x}px;
        top: ${y - 30}px;
        font-size: 16px;
        font-weight: bold;
        color: var(--accent);
        pointer-events: none;
        z-index: 1001;
        animation: pointsFloat 1s ease-out forwards;
        transform: translate(-50%, -50%);
        font-family: 'Press Start 2P', monospace;
      `;
      
      // Add points animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes pointsFloat {
          0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          100% { opacity: 0; transform: translate(-50%, -50%) translateY(-40px) scale(1.2); }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(pointsDiv);
      setTimeout(() => {
        pointsDiv.remove();
        style.remove();
      }, 1000);
    }

    function createPopEffect(x, y) {
      // Play sparkle sound
      setTimeout(() => playSparkleSound(), 100);
      
      const pop = document.createElement('div');
      pop.innerHTML = '‚ú®';
      pop.style.cssText = `
        position: fixed;
        left: ${x}px;
        top: ${y}px;
        font-size: 20px;
        pointer-events: none;
        z-index: 1000;
        animation: sparkle 0.6s ease-out forwards;
        transform: translate(-50%, -50%);
      `;
      
      // Add sparkle animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes sparkle {
          0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(pop);
      setTimeout(() => {
        pop.remove();
        style.remove();
      }, 600);
    }

    // Initialize bubbles and audio when page loads
    document.addEventListener('DOMContentLoaded', () => {
      initAudio();
      initBubbles();
      
      // Initialize audio context on first user interaction (required by browsers)
      document.addEventListener('click', function initAudioOnFirstClick() {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
        document.removeEventListener('click', initAudioOnFirstClick);
      }, { once: true });
    });

    // ===== DOM helpers =====
    const $ = s => document.querySelector(s);
    const show = (sel, on=true) => {
      const el = typeof sel==="string" ? $(sel) : sel;
      if(!el) return; el.classList[on ? "remove":"add"]("hidden");
    };
    const log = (msg, level="") => {
      const out = $("#output");
      const prefix = level==="ok"?"‚úÖ ":level==="warn"?"‚ö†Ô∏è ":level==="err"?"‚õî ":"";
      out.textContent += `${prefix}${msg}\n`;
      out.scrollTop = out.scrollHeight;
    };

    // ===== UI bindings =====
    $("#btnInstructions").addEventListener("click", () => {
      const hidden = $("#instructions").classList.contains("hidden");
      show("#instructions", hidden);
      $("#btnInstructions").textContent = hidden ? "Hide Instructions" : "Show Instructions";
    });
    $("#btnRestartTop").addEventListener("click", restartGame);
    $("#btnSetupPlayers").addEventListener("click", setupPlayers);
    $("#btnStart").addEventListener("click", startGame);
    $("#btnPlay").addEventListener("click", playRound);
    $("#btnReenter").addEventListener("click", () => setupRound(true));

    // ===== Chart setup =====
    let chart;
    function palette(n){
      const base = [
        "#4e79a7","#f28e2b","#e15759","#76b7b2","#59a14f","#edc949",
        "#af7aa1","#ff9da7","#9c755f","#bab0ab","#86b1f2","#f4a259",
        "#c75146","#2ca58d","#8ab17d","#b07aa1","#7f7fff","#00bcd4",
        "#ffd166","#06d6a0","#ef476f"
      ];
      const out=[]; for(let i=0;i<n;i++) out.push(base[i%base.length]);
      return out;
    }
    function ensureChart(){
      const ctx = $("#guessChart");
      if(chart) return chart;
      chart = new Chart(ctx, {
        type: "line",
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          plugins: {
            legend: { position: "bottom", labels: { color: "#e9ecff" } },
            tooltip: { intersect:false, mode:"nearest" }
          },
          scales: {
            x: { ticks:{ color:"#9aa2d0" }, grid:{ color:"#243056" }, title:{ display:true, text:"Round", color:"#9aa2d0" } },
            y: { beginAtZero:true, ticks:{ color:"#9aa2d0" }, grid:{ color:"#243056" }, title:{ display:true, text:"Guess", color:"#9aa2d0" } }
          },
          elements:{ line:{ tension:0.25 }, point:{ radius:3 } }
        }
      });
      return chart;
    }
    function updateChart(){
      const c = ensureChart();
      const maxRounds = Math.max(1, ...players.map(p => p.guesses.length));
      c.data.labels = Array.from({length:maxRounds}, (_,i)=> `R${i+1}`);
      const colors = palette(players.length);
      c.data.datasets = players.map((p, idx) => ({
        label: p.name,
        data: Array.from({length:maxRounds}, (_,i)=> p.guesses[i] ?? null),
        borderColor: colors[idx],
        backgroundColor: colors[idx],
        spanGaps: true
      }));
      c.update();
    }

    // ===== Flow =====
    function setupPlayers(){
      const num = parseInt($("#numPlayers").value,10);
      if(!Number.isInteger(num) || num<2 || num>100){
        log("Please enter a valid number of players (2‚Äì100).","warn"); return;
      }
      const form=$("#playerForm");
      form.innerHTML="";
      for(let i=0;i<num;i++){
        const row=document.createElement("div");
        row.innerHTML=`
          <label>Player ${i+1} Name</label>
          <input type="text" id="player${i}" placeholder="Name" required />
        `;
        form.appendChild(row);
      }
      show("#player-setup", false);
      show("#player-names", true);
    }

    function startGame(){
      const inputs=[...document.querySelectorAll("#playerForm input")];
      const names=inputs.map(i => (i.value||"").trim());
      if(names.some(n => n.length===0)){
        log("Please fill all player names.","warn"); return;
      }
      players=names.map(n => new Player(n));
      roundNumber=1;
  finalMode=false;
  tieMode=false;
  tiePlayers=[];
  tieConstraint.clear();

      show("#player-names", false);
      show("#game", true);
      show("#logwrap", true);
      setupRound();
      updateChart();
    }

    function setupRound(reenter=false){
      const baseEligible = players.filter(p => p.roundsWon === 0);
      finalMode = !tieMode && baseEligible.length === 1; // no tie-break in progress

      $("#round-info").textContent = finalMode ? `Final Round (Round ${roundNumber})` : `Round ${roundNumber}`;

      if(finalMode){
        $("#round-note").textContent = `Only ${baseEligible[0].name} chooses a guess this round. All players still pay the winning amount.`;
      } else if(tieMode){
        const currentLowest = tiePlayers.length ? tiePlayers[0].lastGuess() : "?";
        $("#round-note").textContent = `Tie-break: only tied lowest players re-enter with a bet lower than ${currentLowest}.`;
      } else {
        $("#round-note").textContent = `Only players who haven‚Äôt won yet may guess.`;
      }

      const g=$("#guesses"); g.innerHTML="";
      const toPrompt = tieMode ? tiePlayers : baseEligible;

      toPrompt.forEach((p, i) => {
        const prev = p.lastGuess();
        const needsLower = tieMode && tieConstraint.has(p);
        const maxAttr = needsLower && Number.isFinite(prev) ? `max="${prev-1}"` : "";
        const hint = needsLower && Number.isFinite(prev) ? `<div class="hint">New bet must be &lt; ${prev}</div>` : "";
        const row=document.createElement("div");
        row.className="row";
        row.innerHTML=`
          <div><b>${p.name}</b>‚Äôs guess ${hint}</div>
          <input type="number" step="1" min="0" ${maxAttr} id="guess${i}" placeholder="e.g. 7" required />
        `;
        g.appendChild(row);
      });

      if(!reenter){ renderScoreboard(); }
    }

    function playRound(){
      const baseEligible = players.filter(p => p.roundsWon === 0);
      const activeEligible = tieMode ? tiePlayers : baseEligible;
      const inputs=[...document.querySelectorAll("#guesses input")];

      // Collect guesses
      const submitted=[];
      for(let i=0;i<inputs.length;i++){
        const raw=inputs[i].value.trim();
        if(raw===""){ log(`Missing guess for ${activeEligible[i].name}.`,`warn`); return; }
        const val=Number(raw);
        if(!Number.isInteger(val) || val<0){ log(`${activeEligible[i].name} must enter a non-negative integer.`,`warn`); return; }

        if(tieMode){
          const prevLimit = tieConstraint.get(activeEligible[i]);
            // previous baseline they must go below
          if(!(val < prevLimit)){
            log(`${activeEligible[i].name}: new bet must be lower than your previous tied bet (${prevLimit}).`,`err`); return;
          }
          // Replace last guess (do not extend rounds)
          activeEligible[i].guesses[activeEligible[i].guesses.length-1] = val;
        } else {
          activeEligible[i].makeGuess(val);
        }
        submitted.push(val);
      }

      let winner, winningGuess;

      if(finalMode){
        winner = activeEligible[0];
        winningGuess = winner.lastGuess() ?? 0;
      } else if(tieMode){
        // Evaluate tie-break iteration among current tie players
        const minNow = Math.min(...tiePlayers.map(p => p.lastGuess()));
        const stillTied = tiePlayers.filter(p => p.lastGuess() === minNow);
        if(stillTied.length > 1){
          // Continue tie-break with only those still tied
            tiePlayers = stillTied;
            tieConstraint.clear();
            for(const p of tiePlayers){ tieConstraint.set(p, p.lastGuess()); }
            log(`üîÅ Still tied at ${minNow}. Only tied players re-enter with a lower bet.`, "warn");
            setupRound(true);
            return;
        } else {
          // Tie resolved
          winner = stillTied[0];
          winningGuess = winner.lastGuess();
          tieMode = false;
          tiePlayers = [];
          tieConstraint.clear();
        }
      } else {
        // Normal round resolution
        const minGuess = Math.min(...submitted);
        const minPlayers = activeEligible.filter(p => p.lastGuess() === minGuess);
        if(minPlayers.length > 1){
          // Initiate tie-break with only those at lowest
          tieMode = true;
          tiePlayers = minPlayers;
          tieConstraint.clear();
          for(const p of tiePlayers){ tieConstraint.set(p, p.lastGuess()); }
          for(const p of tiePlayers){
            log(`üîÅ ${p.name}: tied lowest at ${minGuess} ‚Äî enter a new lower bet.`, "warn");
          }
          setupRound(true);
          return;
        }
        winner = minPlayers[0];
        winningGuess = minGuess;
      }

      // Payments: everyone pays winningGuess; winner receives pot
      const totalPlayers = players.length;
      for(const p of players){ p.balance -= winningGuess; }
      winner.balance += winningGuess * totalPlayers;

      // Mark win (only once)
      if(winner.roundsWon === 0){
        winner.roundsWon = 1;
        winner.winningRounds.push(roundNumber);
      }

      const modeLabel = finalMode ? "Final round" : `Round ${roundNumber}`;
      log(`üèÜ ${modeLabel} winner: ${winner.name} ‚Äî winning guess ${winningGuess}.`, "ok");
      log(`‚û°Ô∏è Everyone pays ‚Ç¨${winningGuess}. ${winner.name} receives ‚Ç¨${winningGuess * totalPlayers}.`, "ok");

      roundNumber++;
      updateChart();

      const remaining = players.filter(p => p.roundsWon === 0);

      if(finalMode){
        finishGame();
        return;
      }
      if(remaining.length === 1){
        setupRound(false); // will flip to finalMode next time
        return;
      }
      setupRound(false);
    }

    function renderScoreboard(){
      const el=$("#scoreboard");
      const rows = players.map(p =>
        `<tr>
          <td>${escapeHtml(p.name)}</td>
          <td>${p.roundsWon}</td>
          <td>${p.balance}</td>
          <td>${p.winningRounds.length ? p.winningRounds[0] : "-"}</td>
        </tr>`
      ).join("");
      el.innerHTML = `
        <div class="scoreboard">
          <table>
            <thead><tr><th>Player</th><th>Rounds Won</th><th>Balance (‚Ç¨)</th><th>Winning round</th></tr></thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
    }

    function finishGame(){
      // Chronological recap
      const ordered = players.slice().sort((a,b)=>{
        const af = a.winningRounds[0] ?? Infinity;
        const bf = b.winningRounds[0] ?? Infinity;
        return af - bf;
      });

      log(`\nüèÅ Game Finished\n`, "ok");
      for(const p of ordered){
        const wr = p.winningRounds.length ? p.winningRounds[0] : "None";
        log(`‚Ä¢ ${p.name} ‚Äî Balance: ‚Ç¨${p.balance} | Winning round: ${wr}`);
      }

      renderScoreboard();
      show("#game", false);
      show("#game-finished", true);
    }

    function restartGame(){
  players=[]; roundNumber=1; finalMode=false; tieMode=false; tiePlayers=[]; tieConstraint.clear();
      $("#output").textContent="";
      $("#numPlayers").value="";
      $("#playerForm").innerHTML="";
      $("#guesses").innerHTML="";
      $("#round-info").textContent="";
      $("#round-note").textContent="";
      $("#scoreboard").innerHTML="";
      if(chart){ chart.destroy(); chart=null; }
      show("#game", false);
      show("#logwrap", false);
      show("#game-finished", false);
      show("#player-names", false);
      show("#player-setup", true);
    }

    function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  </script>
</body>
</html>
